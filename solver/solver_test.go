package solver

import (
	"../common"
	"../magnets"
	"testing"
)

func TestNew(t *testing.T) {
	game := magnets.New(5, 6)
	cbs := new(game)

	answer := len(cbs)
	if answer != 6 {
		t.Errorf("ERROR: Expected 6, got %d", answer)
	}
	answer = len(cbs[0])
	if answer != 5 {
		t.Errorf("ERROR: Expected 5, got %d", answer)
	}
	answer = len(cbs[0][0])
	if answer != 3 {
		t.Errorf("ERROR: Expected 2, got %d", answer)
	}
}

func TestSetFrame(t *testing.T) {
	testCases := []struct {
		r        rune
		expected rune
	}{
		{common.Positive, common.Negative},
		{common.Negative, common.Positive},
		{common.Neutral, common.Neutral},
	}

	game := magnets.New(2, 1)
	cbs := new(game)

	for _, testCase := range testCases {
		cbs.setFrame(game, 0, 0, testCase.r)
		answer := game.Guess.Get(0, 1)
		if answer != testCase.expected {
			t.Errorf("ERROR: Expected '%c' got '%c'", testCase.expected, answer)
		}
	}
}

func TestSolve(t *testing.T) {
	testCases := []string{
		"3x3:101,200,011,110,LRTTTBBB*",
		"3x3:011,110,101,020,LRTLRBLR*",
		"3x3:201,201,111,120,LRTTTBBB*",
		"3x3:111,021,111,111,LRTLRBLR*",
		"3x4:212,1202,122,2111,TTTBBBLRTLRB",
		"3x4:212,2021,212,0212,TTTBBBTTTBBB",
		"3x4:122,2111,212,1202,TTTBBBLRTLRB",
		"3x4:221,1121,212,0212,TLRBLRTLRBLR",
		"4x4:1112,1211,1112,1220,TLRTBLRBTLRTBLRB",
		"4x4:1212,0222,1122,1122,TLRTBTTBTBBTBLRB",
		"4x4:0212,0212,0122,1121,TLRTBTTBTBBTBLRB",
		"4x4:1012,0121,0112,1021,TTTTBBBBLRTTLRBB",
		"5x5:23031,22212,22122,32121,TLRTTBTTBBTBBTTBTTBB*BBLR",
		"5x5:03232,22222,12322,32221,LRLRTTLRTBBTTBTTBBTBBLRB*",
		"5x5:31312,30322,13132,21232,LRLRTLRLRBTTLRTBBTTBLRBB*",
		"5x5:21222,31320,12132,22221,LRLRTLRTTBTTBBTBBTTBLRBB*",
		"6x6:331232,222233,330332,232223,LRLRLRLRTTLRTTBBTTBBTTBBLRBBLRLRLRLR",
		"6x6:321223,113233,231313,031333,LRTLRTTTBTTBBBTBBTTTBTTBBBTBBTLRBLRB",
		"6x6:232323,033333,322233,123333,LRTLRTLRBLRBTLRTTTBLRBBBTLRLRTBLRLRB",
		"6x6:223033,323221,132133,322222,LRLRLRLRLRLRLRTTLRTTBBTTBBTTBBLRBBLR",
		"7x7:3243423,4343412,3333333,3434340,TLRTLRTBTTBTTBTBBTBBTBTTBTTBTBBTBBTBTTBTTB*BB*BB*",
		"7x7:2434223,3424322,4242314,4243403,TTTTLRTBBBBTTBLRTTBBTTTBBLRBBBTLRLRLRBLRTTLRLR*BB",
		"7x7:4222414,4233403,3233323,2424340,TTTLRTTBBBTTBBTLRBBLRBLRTTTTLRTBBBBTTBTTTTBB*BBBB",
		"7x7:3341223,4332312,2423043,3323313,TTTTLRTBBBBTTBTTTTBBTBBBBTTBLRLRBBTTTLRLRBBBLRLR*",
		"6x10:535454,3333323033,544445,3333331133,TTLRTTBBTTBBTTBBTTBBLRBBTLRTLRBTTBTTTBBTBBBLRBLRTTLRLRBBLRLR",
		"6x10:244535,3230333321,425345,3221333321,LRLRTTLRTTBBLRBBTTLRLRBBTTTLRTBBBTTBTTTBBTBBBTTBLRTBBTLRBLRB",
		"6x10:533455,3223333321,443545,3322333330,LRTLRTTTBTTBBBTBBTTTBTTBBBTBBTTTBTTBBBTBBTTTBTTBBBTBBTLRBLRB",
		"6x10:434554,3212333323,443545,3203333323,TLRTTTBTTBBBTBBTLRBTTBTTTBBTBBBTTBTTTBBTBBBLRBTTTLRTBBBLRBLR",
		"9x9:334345444,353545441,433444444,534454540,TTTTTTTLRBBBBBBBTTLRLRLRTBBTLRTTTBTTBTTBBBTBBTBBLRTBTTBTTTTBTBBTBBBBTBLRBLRLRBLR*",
	}

	for _, testCase := range testCases {
		game, ok := magnets.Deserialize(testCase)
		if !ok {
			t.Errorf("ERROR: Unable to deserialize %s", testCase)
		}
		Solve(game)
		if !game.Solved() {
			t.Errorf("ERROR: Unable to solve %s", testCase)
		}
	}
}
